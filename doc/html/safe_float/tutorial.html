<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Tutorial</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;safe_float">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;safe_float">
<link rel="prev" href="../index.html" title="Chapter&#160;1.&#160;safe_float">
<link rel="next" href="notes.html" title="Notes">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="notes.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="safe_float.tutorial"></a>Tutorial</h2></div></div></div>
<p>In introduction, we showed an example of how overflow of adding two
    non-infinite float variables produce an infinite result. We reproduce the
    same example here for reference.</p>
<pre class="programlisting">#include &lt;iostream&gt;
#include &lt;limits&gt;

int main(){
using namespace std;
float a = numeric_limits&lt;float&gt;::max();
float b = a + numeric_limits&lt;float&gt;::max();
cout &lt;&lt; "b is " &lt;&lt; b &lt;&lt; endl; //outputs: b is inf

return 0;
}</pre>
<p>If we replace the type used by both variables to
    safe_float&lt;float, check_addition_overflow&gt;, the addition would have
    thrown an exception to inform the user.</p>
<pre class="programlisting">#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;boost/safe_float.hpp&gt;

int main(){
using namespace std;
using namespace boost::safe_float;
try {
    safe_float&lt;float,policy::check_addition_overflow&gt; a = numeric_limits&lt;float&gt;::max();
    safe_float&lt;float,policy::check_addition_overflow&gt; b = a + a;
} catch { const boost::safe_float_exception&amp; e) { 
    cout &lt;&lt; "safe_float required guarantees broken" &lt;&lt; endl;
}    

return 0;
}</pre>
<p>Here the addition throws an exception informing the user that one of
    the requirements was not covered by the operation result. It is important
    to notice safe_float does nothing to fix this, the task of the library is
    detect and inform only, user needs to handle the detected problems.</p>
<p>The minimal granularity of a checking policies is checking one
    operation for a single concern. They can be composed for providing more
    complex checks and affect more operations. The library includes several
    common use compositions under the convenience.hpp file and it is easy to
    introduce new checks for particular purposes if needed. The complete list
    of policies can be found in the Policies section of the
    documentation.</p>
<p>In some contexts, as real-time critical systems, the use of
    exceptions is restricted or fully deactivated. For this contexts, it is
    useful to specify other error handling methods to be used.</p>
<p>The following is a example of how to use the library for asserting
    in place of throwing.</p>
<pre class="programlisting">#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;boost/safe_float.hpp&gt;

int main(){
using namespace std;
using namespace boost::safe_float;
safe_float&lt;float,policy::check_overflow,policy::on_fail_assert&gt; a = numeric_limits&lt;float&gt;::max();
safe_float&lt;float,policy::check_overflow,policy::on_fail_assert&gt; b = a + a;

return 0;
}</pre>
<p>Here, assert will be used in place of throw aborting execution and
    informing in debug mode, but having no impact at all in the release mode.
    Other alternatives include abort_on_fail, throw_on_fail, unexpected_on_fail, and log_on_fail.</p>
<p>Another template parameter available is the conversion (or cast)
    policy, this is responsable of deciding how the data type will play with
    others. The default is not interacting with any other. In some cases, we
    would like to accept the wrapped type as parameter of the
    operations.</p>
<p>The following is an example allowing addition-assigment with wrapped
    type parameter.</p>
<pre class="programlisting">#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;boost/safe_float.hpp&gt;

int main(){
using namespace std;
using namespace boost::safe_float;
safe_float&lt;float,policy::check_overflow,policy::on_fail_assert,policy::accept_wrappedtype_params&gt; a = numeric_limits&lt;float&gt;::max();

a += 3.14f; //ok because of accept_wrappedtype_params

return 0;
}</pre>
<p> The opposite would be to chose policy::strict_type, which only accepts values produced using safefloat operations
or literals constructed using the safefloat literal suffix.</p>
<pre class="programlisting">
include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;boost/safe_float.hpp&gt;

int main(){
using namespace std;
using namespace boost::safe_float;
safe_float&lt;float,policy::check_overflow,policy::on_fail_assert,policy::strict_type&gt; a = numeric_limits&lt;float&gt;::max(); // fails compilation because max is not using safefloat literal suffix
safe_float &lt;float,policy::check_overflow,policy::on_fail_assert,policy::strict_type&gt; b = 0.3_sf; //fails compilation because 0.3 is not representable in float
safe_float &lt;float,policy::check_overflow,policy::on_fail_assert,policy::strict_type&gt; b = 0.5_sf; //constructs succesfully a safefloat of internal value 0.5f
</pre>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2015-2018 Dami&#225;n Vicino<p><a href="http://www.boost.org/users/license.html" target="_top">BOOST
      License</a></p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="notes.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
