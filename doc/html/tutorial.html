<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Tutorial</title>
<link rel="stylesheet" href="boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="index.html" title="SafeFloat">
<link rel="up" href="index.html" title="SafeFloat">
<link rel="prev" href="introduction.html" title="Introduction">
<link rel="next" href="notes.html" title="Notes">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img href="index.html" height="164px" src="pre-boost.jpg" alt="Library Documentation Index"></td>
<td><h2>SafeFloat</h2></td>
</tr></table>
<div class="spirit-nav">
<a accesskey="p" href="introduction.html"><img src="images/prev.png" alt="Prev"></a><a accesskey="u" href="index.html"><img src="images/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"></a><a accesskey="n" href="notes.html"><img src="images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="safefloat.tutorial"></a>Tutorial</h2></div></div></div>
<p>In introduction, we showed an example of how overflow of adding two
    non-infinite float variables produce an infinite result. We reproduce the
    same example here for reference.</p>
<pre class="programlisting">#include &lt;iostream&gt;
#include &lt;limits&gt;

int main(){
using namespace std;
float a = numeric_limits&lt;float&gt;::max();
float b = a + numeric_limits&lt;float&gt;::max();
cout &lt;&lt; "b is " &lt;&lt; b &lt;&lt; endl; //outputs: b is inf

return 0;
}</pre>
<p>If we replace the type used by both variables to
    safe_float&lt;float, no_overflow_on_addition&gt;, the addition would have
    throw an exception to inform the user.</p>
<pre class="programlisting">#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;boost/safefloat.hpp&gt;

int main(){
using namespace std;
using namespace boost::safefloat;
try {
    safe_float&lt;float,policy::no_overflow_on_addition&gt; a = numeric_limits&lt;float&gt;::max();
    safe_float&lt;float,policy::no_overflow_on_addition&gt; b = a + a;
} catch { const boost::safe_float_exception&amp; e) { 
    cout &lt;&lt; "safe_float required guarantees broken" &lt;&lt; endl;
}    

return 0;
}</pre>
<p>Here the addition throws a safe_float exception informing the user
    that one of the requirements was not covered by the operation result. It
    is important to notice safe_float does nothing to fix this, the task of
    the library is detect and inform only, user needs to handle the detected
    problems.</p>
<p>The minimal granularity of a checking policies is checking one
    operation for a single restriction. They can be composed for providing
    more complex checks and affect more operations. The library includes
    several common use compositions under the convenience.hpp file and it is
    easy to introduce new checks for particular purposes if needed. The
    complete list of policies can be found in the Policies section of the
    documentation. </p>
<p>In some contexts, as real-time critical systems, the use of
    exceptions is restricted or fully deactivated. For this contexts, it is
    useful to specify other error handling methods to be used. </p>
<p>The following is a example of how to use the library for asserting
    in place of throwing.</p>
<pre class="programlisting">#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;boost/safefloat.hpp&gt;

int main(){
using namespace std;
using namespace boost::safefloat;
safe_float&lt;float,policy::no_overflow,policy::assert_on_fail&gt; a = numeric_limits&lt;float&gt;::max();
safe_float&lt;float,policy::no_overflow,policy::assert_on_fail&gt; b = a + a;

return 0;
}</pre>
<p>Here, assert will be used in place of throw aborting execution and
    informing in debug mode, but having no impact at all in the release mode.
    Other alternatives include abort_on_fail and log_on_fail.</p>
<p>Another template parameter available is the conversion policy, this
    is responsable of deciding how the data type will play with others. The
    default is not interacting with any other. In some cases, we would like to
    accept the wrapped type as parameter of the operations.</p>
<p>The following is an example allowing addition-assigment with wrapped
    type parameter.</p>
<pre class="programlisting">#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;boost/safefloat.hpp&gt;

int main(){
using namespace std;
using namespace boost::safefloat;
safe_float&lt;float,policy::no_overflow,policy::assert_on_fail,policy::accept_wrappedtype_params&gt; a = numeric_limits&lt;float&gt;::max();

a += 3.14f; //ok because of accept_wrappedtype_params

return 0;
}</pre>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2015 Dami&#225;n Vicino<p><a href="http://www.boost.org/users/license.html" target="_top">BOOST
      License</a></p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="introduction.html"><img src="images/prev.png" alt="Prev"></a><a accesskey="u" href="index.html"><img src="images/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"></a><a accesskey="n" href="notes.html"><img src="images/next.png" alt="Next"></a>
</div>
</body>
</html>
